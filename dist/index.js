var l=-3,c=-2,p=-1;function f(e){let n=e.map(x).sort(I),r=0;for(let i=1;i<n.length;i++){let a=n[i],t=n[r];a.start>t.end+1?n[++r]=a:a.end>t.end&&(t.end=a.end,t.index=Math.min(t.index,a.index))}n.length=r+1;let o=n.sort(b).map(m);return o.type=e.type,o}function x(e,n){return{end:e.end,index:n,start:e.start}}function m(e){return{end:e.end,start:e.start}}function b(e,n){return e.index-n.index}function I(e,n){return e.start-n.start}var g=class extends Array{constructor(){super(...arguments);this.type=""}toArray(){let n=Array.from(this);return n.type=this.type,n}};function h(e,n,r){let o=!0;if(r&&"throwError"in r&&r.throwError===!1&&(o=!1),!Number.isInteger(e)){if(o)throw new TypeError("Argument 'size' must be an integer.");return l}if(typeof n!="string"){if(o)throw new TypeError("Argument 'header' must be a string.");return l}let i=n.indexOf("=");if(i===-1)return c;let a=n.slice(i+1).split(","),t=new g;t.type=n.slice(0,i);for(let d=0;d<a.length;d++){let R=a[d].split("-"),u=Number.parseInt(R[0],10),s=Number.parseInt(R[1],10);Number.isNaN(u)?(u=e-s,s=e-1):Number.isNaN(s)&&(s=e-1),s>e-1&&(s=e-1),!(Number.isNaN(u)||Number.isNaN(s)||u>s||u<0)&&t.push({end:s,start:u})}return t.length<1?p:r&&r.combine?f(t):t}export{l as ERROR_INVALID_ARGUMENT,c as ERROR_STRING_IS_NOT_HEADER,p as ERROR_UNSATISFIABLE_RESULT,g as HeaderRanges,h as parseRange};
